# Как работает интернет

Что происходит за экраном когда вы печатайте google.com в браузере?

**Оглавление**

- [Кнопка 'g' нажата](#googles-g-key-is-pressed)
- [Когда вы нажмете «Enter»](#when-you-hit-enter)
- [Парсинг URL(Урла)](#parse-the-url)
- [Проверка списка HSTS](#check-hsts-list)
- [Обращение к DNS](#dns-lookup)
- [Opening of a socket(Открытие сокета) + TLS handshake(рукопожатие TLS)](#opening-of-a-socket--tls-handshake)
- [HTTP протокол](#http-protocol)
- [HTTP Сервер (Server Request Handle)](#http-server-request-handle)
- [Ответ сервера](#server-response)
- [Behind the scenes of the Browser](#behind-the-scenes-of-the-browser)
- [The browser's high level structure](#the-browsers-high-level-structure)
- [Rendering Engine](#rendering-engine)
- [The Main flow](#the-main-flow)
- [Parsing Basics](#parsing-basics)
- [DOM Tree](#dom-tree)
- [Render Tree](#render-tree)
- [Render tree's relation to the DOM tree](#render-trees-relation-to-the-dom-tree)
- [CSS Parsing](#css-parsing)
- [Layout](#layout)
- [Painting](#painting)
- [Trivia](#trivia)

## Кнопка 'g' нажата

Когда вы просто нажмете «g», браузер получит событие, и весь механизм автодополнения начнет работать на полную мощность. В зависимости от алгоритма вашего браузера, и если вы находитесь в режиме приват/инкогнито или нет, вам будут предложены различные предложения в выпадающем списке под строкой URL. Большинство из этих алгоритмов устанавливают приоритеты результатов на основе истории поиска и закладок. Вы наберете "google.com", так что ничего из этого не имеет значения, но перед тем, как вы туда доберетесь, будет выполнено много кода, и предложения будут уточняться при каждом нажатии клавиши. Он может даже предложить "google.com", прежде чем вводить его.

## Когда вы нажмете «Enter»

Чтобы выбрать начальную точку, давайте выберем клавишу Enter на клавиатуре, попав в нижнюю часть ее диапазона. В этот момент электрическая цепь, специфичная для клавиши ввода, замыкается (напрямую или емкостно). Это позволяет небольшому количеству тока течь в логические схемы клавиатуры, которая сканирует состояние каждого клавишного переключателя, устраняет электрические помехи быстрого прерывистого замыкания переключателя и преобразует его в целое число кода клавиши, в этом случае 13. Затем контроллер клавиатуры кодирует код клавиши для передачи на компьютер. Теперь это почти универсально через универсальную последовательную шину (USB) или соединение Bluetooth.

Когда клавиатура USB:
* Сгенерированный код ключа сохраняется во внутренней памяти клавиатуры в регистре, называемом «конечной точкой».
* Хост-контроллер USB опрашивает эту «конечную точку» каждые ~ 10 мс, поэтому он получает сохраненное на нем значение кода ключа.
* Это значение относится к USB SIE (Serial Interface Engine), отправляемому с максимальной скоростью 1,5 Мбит / с (USB 2.0).
* Этот последовательный сигнал затем декодируется на главном USB-контроллере компьютера и интерпретируется драйвером универсального клавиатурного устройства Human Interface Device (HID) компьютера. 
* Значение ключа затем передается на уровень аппаратной абстракции операционной системы.

Если клавиатура сенсорная:
* Когда пользователь кладет палец на современный емкостный сенсорный экран, небольшое количество тока передается на палец. Это завершает цепь через электростатическое поле проводящего слоя и создает падение напряжения в этой точке экрана. Затем контроллер экрана вызывает прерывание, сообщая координату «щелчка».
* Затем мобильная ОС уведомляет текущее целевое приложение о событии щелчка в одном из своих элементов графического интерфейса (который теперь является кнопками приложения виртуальной клавиатуры).
* Виртуальная клавиатура теперь может вызывать программное прерывание для отправки сообщения «нажата клавиша» обратно в ОС.
* Это прерывание уведомляет текущее приложение о событии «нажатие клавиши».

## Парсинг URL(Урла)

У браузера теперь есть следующая информация, содержащаяся в URL (Uniform Resource Locator):
* Протокол "http": Используй 'Hyper Text Transfer Protocol'
* Ресурс "/": Получение главной (index) страницы

Если отсутсвует протокол или не корректное доменное имя, тогда браузер переходит к тексту, указанному в поле адреса и обращается к поисковой системе браузера.


## Проверка списка HSTS

* Браузер проверяет свой список «предварительно загруженных HSTS (HTTP Strict Transport Security)». Это список веб-сайтов, к которым обращались только через HTTPS.
* Если веб-сайт находится в списке, браузер отправляет запрос через HTTPS вместо HTTP. В противном случае первоначальный запрос отправляется через HTTP.

Примечание: Веб-сайт все еще может использовать политику HSTS, не входя в список HSTS. На первый HTTP-запрос пользователя на веб-сайт будет получен ответ с запросом о том, чтобы пользователь отправлял только HTTPS-запросы. Однако этот единственный HTTP-запрос может потенциально сделать пользователя уязвимым для [атаки с понижением рейтинга](http://www.yourdictionary.com/downgrade-attack), which is поэтому список HSTS включен в современные веб-браузеры.

## Обращение к DNS

Браузер пытается выяснить IP-адрес для введенного домена. Поиск в DNS происходит следующим образом:

* **Browser cache(кеш браузера):** Браузер кеширует записи DNS в течение некоторого времени. Интересно, что ОС не сообщает браузеру время жизни каждой DNS-записи, и поэтому браузер кеширует их в течение фиксированного периода времени (варьируется в зависимости от браузера от 2 до 30 минут).
* **OS cache(кеш операционной системы):** Если кеш браузера не содержит нужной записи, браузер выполняет системный вызов(gethostbyname в Windows). У операционной системы есть свой кеш.
* **Router cache(Кэш маршрутизатора):**  Запрос отправляется на ваш маршрутизатор, который обычно тоже имеет свой собственный кэш DNS.
* **ISP DNS cache(DNS-кеш интернет-провайдера):** Следующее место - DNS-сервер интернет-провайдера. С кешем, естественно.
* **Recursive search(Рекурсивный поиск:):** DNS-сервер вашего интернет-провайдера начинает рекурсивный поиск от корневого сервера имен через сервер имен верхнего уровня .com до сервера имен Google. Обычно DNS-сервер будет иметь в кеше имена .com, поэтому обращение к корневому серверу имен не потребуется.

Вот схема того, как выглядит рекурсивный поиск DNS:

<p align="center">
  <img src="http://igoro.com/wordpress/wp-content/uploads/2010/02/500pxAn_example_of_theoretical_DNS_recursion_svg.png" alt="Recursive DNS search"/>
</p>

Одна из проблем, связанных с DNS, заключается в том, что все домены, такой как wikipedia.org или facebook.com, обычно, отображаются на один IP-адрес. К счастью, существуют способы устранения этого узкого места:

* **Round-robin DNS**  - это решение, при котором поиск в DNS возвращает несколько IP-адресов, а не один. Например, facebook.com фактически отображается на четыре IP-адреса.
* **Load-balancer(Балансировщик нагрузки)**  - это аппаратная часть, которая прослушивает определенный IP-адрес и перенаправляет запросы на другие серверы. Крупные сайты обычно используют дорогие высокопроизводительные балансировщики нагрузки.
* **Geographic DNS(Геораспределенный)** улучшает масштабируемость, сопоставление доменных имен с различными IP-адресами, в зависимости от географического расположения клиента. Это отлично выход+ для размещения статического контента, так что разные серверы не должны обновлять общее состояние.
* **Anycast**- это метод маршрутизации, при котором один IP-адрес отображается на несколько физических серверов. К сожалению, anycast плохо подходит для протокола TCP и редко используется в этом сценарии.


Большинство DNS-серверов сами используют anycast для достижения высокой доступности и низкой задержки при поиске в DNS. Пользователи сервиса anycast (отличный пример DNS) всегда будут подключаться к «ближайшему» (с точки зрения протокола маршрутизации) DNS-серверу. Это уменьшает задержку, а также обеспечивает уровень балансировки нагрузки (при условии, что ваши потребители равномерно распределены по вашей сети).


## Opening of a socket(Открытие сокета) + TLS handshake(рукопожатие TLS)

* Как только браузер получает IP-адрес сервера назначения, он берет этот URL-адрес и номер порта из URL-адреса (протокол HTTP по умолчанию использует порт 80, а HTTPS - порт 443) и выполняет вызов функции системной библиотеки с именем сокет и запрашивает [TCP](http://www.webopedia.com/TERM/T/TCP.html) [socket](http://www.webopedia.com/TERM/S/socket.html) поток.
* Клиентский компьютер отправляет сообщение ClientHello на сервер с его версией TLS, списком доступных алгоритмов шифрования и методами сжатия.
*Сервер отправляет клиенту сообщение ServerHello с версией TLS, выбранным шифром, выбранными методами сжатия и общедоступным сертификатом сервера, подписанным центром сертификации (CA - Certificate Authority) (центром сертификации). Сертификат содержит открытый ключ, который будет использоваться клиентом для шифрования остальной части рукопожатия, пока не будет согласован симметричный ключ.
* Клиент проверяет цифровой сертификат сервера по списку доверенных ЦС. Если доверие может быть установлено на основе CA, клиент генерирует строку псевдослучайных байтов и шифрует ее с помощью открытого ключа сервера. Эти случайные байты могут быть использованы для определения симметричного ключа.
* Сервер расшифровывает случайные байты, используя свой закрытый ключ, и использует эти байты для генерации своей собственной копии симметричного главного ключа.
* Клиент отправляет сообщение Finished на сервер, зашифровывая хэш передачи до этой точки симметричным ключом.
* Сервер генерирует свой собственный хеш, а затем расшифровывает отправленный клиентом хеш, чтобы убедиться, что он совпадает. Если это так, он отправляет собственное сообщение «Готово» клиенту, также зашифрованное с помощью симметричного ключа.
* Отныне сеанс TLS передает данные приложения (HTTP), зашифрованные согласованным симметричным ключом.

## HTTP протокол

Вы можете быть совершенно уверены, что динамические сайты, такие как Facebook / Gmail, не будут обслуживаться из кэша браузера, поскольку срок действия динамических страниц истекает либо очень быстро, либо сразу (дата окончания срока действия установлена ​​на прошлое).

Если используемый веб-браузер был написан Google, вместо того, чтобы отправлять HTTP-запрос на получение страницы, он отправит запрос на попытку согласовать с сервером «обновление» с HTTP до протокола SPDY. Обратите внимание, что SPDY считается устаревшим в пользу HTTP / 2 в последних версиях Chrome.

```txt
GET http://www.google.com/ HTTP/1.1
Accept: application/x-ms-application, image/jpeg, application/xaml+xml, [...]
User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; [...]
Accept-Encoding: gzip, deflate
Connection: Keep-Alive
Host: google.com
Cookie: datr=1265876274-[...]; locale=en_US; lsd=WW[...]; c_user=2101[...]
```

В запросе GET указывается URL-адрес для получения: “http://www.google.com/”. Браузер идентифицирует себя (заголовок User-Agent) и указывает, какие типы ответов он будет принимать (заголовки Accept и Accept-Encoding). Заголовок Connection просит сервер оставить TCP-соединение открытым для дальнейших запросов.

Запрос также содержит куки, которые браузер имеет для этого домена. Как вы, вероятно, уже знаете, файлы cookie - это пары ключ-значение, которые отслеживают состояние веб-сайта между запросами к различным страницам. Таким образом, файлы cookie хранят имя вошедшего в систему пользователя, секретный номер, который был назначен пользователю сервером, некоторые настройки пользователя и т. Д. Файлы cookie будут сохранены в текстовом файле на клиенте и отправлены на сервер при каждом запросе.

HTTP/1.1 определяет опцию «закрыть» соединение для отправителя, чтобы сигнализировать, что соединение будет закрыто после завершения ответа. Например,  Connection: close.

После отправки запроса и заголовков веб-браузер отправляет на сервер одну пустую новую строку, указывающую, что содержание запроса выполнено. Сервер отвечает кодом ответа, обозначающим состояние запроса, и отвечает ответом в форме: **200 OK [response headers(заголовки ответа)]**

Затем следует одна новая строка, а затем отправляется полезная нагрузка HTML-контента www.google.com. Затем сервер может либо закрыть соединение, либо оставить открытым, если заголовки отправленные клиентом, запросили  оставить соединение открытым для повторного использования для дальнейших запросов.

Если заголовки HTTP, отправленные веб-браузером, содержали достаточную информацию для веб-сервера, чтобы определить, была ли версия файла, кэшированная веб-браузером, неизменной со времени последнего поиска (т. Е. Если веб-браузер включал заголовок ETag), он вместо этого может ответить запросом в форме: **304 Not Modified [response headers](Не изменено [заголовки ответа])** и без полезной нагрузки,  веб-браузер вместо этого извлекает HTML из своего кэша.

После анализа HTML веб-браузер (и сервер) повторяет этот процесс для каждого ресурса (изображения, CSS, favicon.ico и т. Д.), На который ссылается страница HTML, за исключением того, что вместо GET / HTTP / 1.1 запрос будет **GET /$(URL relative to www.google.com) HTTP/1.1.**

Если HTML-ссылка ссылается на ресурс в домене, отличном от www.google.com, веб-браузер возвращается к шагам, связанным с разрешением другого домена, и выполняет все шаги до этого момента для этого домена. В заголовке Host в запросе будет указано соответствующее имя сервера вместо google.com.

**Gotcha(попался):** 
* Конечная косая черта в URL “http://facebook.com/” важна.  В этом случае браузер может смело добавлять косую черту. Для URL-адресов вида http://example.com/folderOrFile, браузер не может автоматически добавлять косую черту,поскольку неясно, является ли folderOrFile папкой или файлом. В таких случаях браузер будет посещать URL-адрес без косой черты, а сервер ответит перенаправлением, что приведет к ненужному обращению туда и сюда.
* Сервер может ответить 301 Moved Permanently, чтобы браузер сказал  “http://www.google.com/” вместо “http://google.com/”.Существуют несколько причин, по которым сервер настаивает на перенаправлении, а не сразу отвечает веб-страницей, которую хочет видеть пользователь.
Одна из причин связана с рейтингом в поисковых системах.  Смотрите, если есть две ссылки на одну и ту же страницу, скажем http://www.vasanth.com/ и http://vasanth.com/, поисковая система может рассматривать их как два разных сайта, каждый с меньшим количеством входящих ссылок и более низким рейтингом. Поисковые системы понимают постоянные перенаправления (301) и будут объединять входящие ссылки из обоих источников в единый рейтинг. 
Кроме того, несколько URL-адресов для одного и того же содержимого не подходят для кэширования. Когда часть содержимого имеет несколько имен, она потенциально может появляться несколько раз в кеше.

**Заметка:**
HTTP-ответ начинается с возвращенного кода состояния с сервера. Ниже приводится очень краткое изложение того, что обозначает код состояния:       
  * 1xx обозначает только информационное сообщение
  * 2xx положительный ответ
  * 3xx перенаправление на другой URL
  * 4xx ошибка на стороне клиента
  * 5xx ошибка на стороне сервера
 
## HTTP Сервер (Server Request Handle)

HTTPD (HTTP Daemon) - это сервер, обрабатывающий запросы / ответы на стороне сервера. Наиболее распространенными серверами HTTPD являются Apache или nginx для Linux и IIS для Windows.

* HTTPD (HTTP Daemon) получает запрос.

* Сервер разбивает запрос на следующие параметры::
    * Метод HTTP-запроса (GET, POST, HEAD, PUT and DELETE). В случае URL-адреса, введенного непосредственно в адресную строку, это будет GET.
    * Домен, в данном случае - google.com.
    * Запрашиваемый путь / страница, в данном случае - / (так как не был указан конкретный путь / страница, / это путь по умолчанию).
    * Сервер проверяет, что на сервере настроен виртуальный хост, соответствующий google.com.

* Сервер подтверждает, что google.com может принимать запросы GET.

* Сервер проверяет, что клиенту разрешено использовать этот метод (по IP, аутентификации и тд).

* Если на сервере установлен модуль перезаписи (например, mod_rewrite для Apache или URL Rewrite для IIS), он пытается сопоставить запрос с одним из настроенных правил. Если найдено соответствующее правило, сервер использует это правило для перезаписи запроса.

* Сервер отправляет содержимое, соответствующее запросу, в нашем случае он возвращается к файлу индекса, так как «/» является основным файлом (в некоторых случаях это можно переопределить, но это наиболее распространенный метод).

* Сервер анализирует файл в соответствии с обработчиком запроса. Обработчик запросов - это программа (в ASP.NET, PHP, Ruby,…), которая читает запрос и генерирует HTML-код для ответа. Если Google работает на PHP, сервер использует PHP для интерпретации индексного файла и передает выходные данные клиенту.

Примечание: Одна интересная проблема, с которой сталкивается каждый динамический веб-сайт, заключается в том, как хранить данные. Небольшие сайты часто имеют одну базу данных SQL для хранения своих данных, но сайты, которые хранят большой объем данных и / или имеют много посетителей, должны найти способ разделить базу данных на несколько компьютеров. Решения включают разделение (разделение таблицы по нескольким базам данных на основе первичного ключа), репликацию и использование упрощенных баз данных с ослабленной семантикой согласованности.

## Ответ сервера

Вот ответ, который сервер сгенерировал и отправил обратно:

```txt
HTTP/1.1 200 OK
Cache-Control: private, no-store, no-cache, must-revalidate, post-check=0,
    pre-check=0
Expires: Sat, 01 Jan 2000 00:00:00 GMT
P3P: CP="DSP LAW"
Pragma: no-cache
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
X-Cnection: close
Transfer-Encoding: chunked
Date: Fri, 12 Feb 2010 09:05:55 GMT

2b3
��������T�n�@����[...]
```

Весь ответ составляет 36 кБ, основная их часть в байтовом объекте в конце, который я обрезал.

Заголовок  **Content-Encoding** сообщает браузеру, что тело ответа сжато с использованием алгоритма gzip. После распаковки большого двоичного объекта вы увидите ожидаемый HTML-код:

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"   
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" 
      lang="en" id="google" class=" no_js">
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-language" content="en" />
...
```

NОбратите внимание на заголовок, который устанавливает Content-Type в text/html. Заголовок инструктирует браузер отображать содержимое ответа в виде HTML, а не загружать его в виде файла. Браузер будет использовать заголовок, чтобы решить, как интерпретировать ответ, но будет учитывать и другие факторы, такие как расширение URL.
